---
title: c++ quiz
date: June 2, 2012
---

:PostID: 172
:Title: c++ quiz
:Keywords: c++, quiz
:Categories: notes

Рассмотрим простую прогу с наследованием:

.. code-block:: cpp

    #include <stdio.h>
    //
    struct C {
        C() {
            printf ("- C::C()\n");
        }
    };
    struct D : public C {
        D(const C & o) : owner (o) {
            printf ("  `-D::D()\n");
        }
      private:
        const C & owner;
    };
    //
    int main() {
        C c;
        //
        D d1(c);
        D d2(d1);
        //
        return 0;
    }

Вопрос: **что она выведет**?

.. raw:: html

   <!--more-->

Чтобы окончательно вас сбить с толку рассмотрим объявленные
и используемые в программе конструкторы для **D**:

.. code-block:: cpp

    struct D : public C {
        D(const C & o) {
        // ....
        }
        // ...
    }
    //
    int main() {
        C c;
        //
        D d1(c);  // [1]
        D d2(d1); // [2]
        // ...
    }


Итак, **ответ**:

.. code-block:: bash

    $ g++ a.cc -o a && ./a
    - C::C()
    - C::C()
      `-D::D()
    # а конструктора для d2 и нет! :]

**Как так?**

А вот как:

- В **[1]** используется конструктор **D::D(const C &)**
- В **[2]** используется конструктор копии **D::D(const D &)** (**генерится компилятором**)

Конструктор копии по умолчанию в нашем случае выглядит примерно так:

.. code-block:: cpp

        C::C(const C & c)
        {}
        D::D(const D & d) : C(d), owner (d.owner)
        {}

Часто это довольно гадкий и нежелательный эффект. В моём случае **class С**
был низкоуровневым классом помощи посчета ссылок, для которого конструктор
копии по умолчанию **делал полную фигню и плодил утечки памяти**.

Реальный код, в котором я вчера нашел этот эффект не предполагал создания
копии и должен был быть написан следующим образом:

.. code-block:: cpp

    //
    int main() {
        C c;
        //
        D d1(c);
        D d2(static_cast<const C &>(d1)); // как для 'd1'
        //
        return 0;
    }

Чтобы впредь избежать проблем в дочерних классах, наследуемых от
**class С** я просто спрятал конструкторы копии и присваивания:

.. code-block:: cpp

    #include <stdio.h>
    //
    struct C {
        C() {
            printf ("- C::C()\n");
        }
      private:
        C(const C &);              /* forbidden */
        C & operator= (const C &); /* forbidden */
    };

В этом случае компилятор начнет ныть, что не может
вызвать конструктор копии:

.. code-block:: bash

    В функции «int main()»:
     замечание: synthesized method «D::D(const D&)» first required here

Добавление этого кода позволило найти еще пару таких-же проблемных мест.
